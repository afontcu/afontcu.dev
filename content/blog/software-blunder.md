---
title: "Blundering your software"
description: 'Software development is like a chess game.'
date: '2021-03-24T12:56:01.115Z'
categories: ''
tags: ['Random Thoughts']
slug: software-blunder
---

I like chess. It is a game where principles are paramount and easy to grasp. Still, their implications are hard to grasp for our brain ([not kidding](https://afontcu.dev/neural-networks-apocalypse/)).

Now, I tend to lose. I lose because I don't pay attention. I oversee threats and take dangerous paths, and I realize when it's too late.

Why did this happen? I think I was using the wrong mental model.

I thought I needed to play perfect games in order to win. Turns out, though, that winning a chess game is just a matter of not blundering and [waiting for your opponent to do so](https://youtu.be/TY41yF1gX1w?t=21).

It is not about playing great, groundbreaking moves all the time. I mostly play reasonably good moves, and then blow everything up by making an awful one.

Now, this is a principle. Putting it in action is another story.

## Chess and software

What I came up to discover is that this applies to my daily job, too.

You are not supposed to find the hidden gem, the ultimate feature that makes your product skyrocket or its performance to improve a thousand times.

You could do so if you had infinite time to think, to analyze the position and act accordingly. But that's not the case.

As in chess, you're simply supposed **not to blunder**.

You're supposed to take small, safe steps **that** leave you better than you were right before. Or exactly the same, [depending on your context](https://medium.com/@kentbeck_7670/the-product-development-triathlon-6464e2763c46).

Now – you don't have opponents here. Well, there's your competition, but that's way more… indirect than when you play chess.

However, some software decisions might be really, really bad for your product and your business. There's also the opportunity cost – there are many good things you could be doing instead of making that terrible move. And feel free to translate *"that terrible move"* to *"that feature nobody is gonna use"* or *"that new framework that we really, really need to start using on production"*.

Truth hurts.

## How can we do so?

We already know the answer.

We need to avoid footguns.

But yeah, just as if we were talking about chess again, knowing the answer is the easy part. The implications, though? They are huge.

## Some implications

Taking small, improving steps mean writing code that's deployable every few minutes.

Writing software that let us know about its health (through metrics) as soon as it is available to our users (if not before!).

It also means software that does what it is supposed to do, and we have proof of that (give me a T!, give me an E!, give me a S!, give me a T!, give me a S!).

Also, writing software that's easy to extend. This is really, really hard, because you need to have the skills to write it, plus the experience to know where might software need to grow and accept new features and capabilities.

Moreover, it means knowing what direction you want to move.

## Try not to lose

Playing it safe doesn't mean not taking risks. It means knowing that you take them and creating the required safety net around them.